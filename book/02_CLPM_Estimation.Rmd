# Panel Data Analysis

The package that accompanies this summary, `crossLagR`, includes functions to estimate several panel data models.

**Install and Load**

```{r}
# devtools::install_github("https://github.com/crweber9874/crossLagR/crossLagR")
library(crossLagR)
```

* `estimateCLPM()` generates the syntax for cross-lagged panel models. Use `help(estimateRICLPM)` to modify constraints and number of waves.
* `estimateRICLPM()` generates the syntax for random-intercept cross-lagged panel models. Use `help(estimateRICLPM)` to modify constraints and number of waves.
* `estimateLChange()` generates the syntax for latent change score model. Use `help(estimateLChange)` to modify constraints and number of waves.

Nearly all the functions in the package start with a core lavaan model -- such as the RICLPM [@hamaker2015]. From there, build in rules to implement constraints, extend the number of waves, and modify parameters. You could just print the model code and modify manually. For instance, the `lavaan` code to estimate the CLPM is,

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
estimateCLPM(waves = 2,
                         constrain_beta = TRUE,
                         constrain_omega = TRUE,
                         constrain_residual_variances = TRUE,
                         constrain_residual_covariances = TRUE,
                         estimate_means = FALSE) |>
cat()
```  

The `lavaan` code to estimate the Bivariate Latent Change Model is,

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
rm(list = ls())
devtools::load_all()
estimateLChange(waves = 3,
                variable_type = "bivariate",
                constrain_omega = TRUE,
                constrain_beta =  TRUE) |>
  cat()
```

And the RICLPM model is,

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
rm(list = ls())
devtools::load_all()
estimateRICLPM(waves = 3,
                constrain_omega = TRUE,
                constrain_beta =  TRUE) |>
  cat()
```
                       
And finally, the Bivariate Latent (Linear) Growth Model,

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
estimateLGM(waves = 3,
            variable_type = "bivariate"
) |>
cat()
```  

## Simulation

As a simple motivating example, simulate data from a CLPM and simply estimate two regression models, one with AR and CL parameters and one on the change scores. The regression models are just OLS models, one using change scores, the other using lags. Not surprisingly, they are interchangeable.

```{r, echo = TRUE, message = FALSE, error = FALSE}
# Simulate a five wave panel, with two variables, x y:
simCLPM(waves = 5)$data |> 
  reshape_long_sim_cr() -> wide_data

data = wide_data |>
  group_by(id) |>
  mutate(
    y_lag = lag(y),
    x_lag = lag(x),
    delta_y = y - lag(y)
  ) |>
  ungroup() -> data
head(data)
```

Let's assume that we have data generated from a latent change model, with constant change, and we estimate two OLS models, one predicting change scores, the other predicting level scores.

```{r, echo = FALSE, message = FALSE, error = FALSE}
lm(delta_y ~ y_lag + x_lag, data = data) |> summary()
lm(y ~ y_lag + x_lag, data = data) |> summary()
```
If we simulate data under a latent change model, with no constant change, the CLPM and difference parameters should align.

```{r}
simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.7,    # This should give CLPM beta ≈ 0.3
  beta_y = -0.7,    # This should give CLPM beta ≈ 0.3
  omega_x = 0.5,    # Cross-lagged coupling effects
  omega_y = 0.5,
  estimate_constant_change = FALSE,  # Important: no constant change
  sample.nobs = 10000
)$data |>
  reshape_long_sim_cr() |>
  group_by(id) |>
    mutate(
      y_lag = lag(y),
      x_lag = lag(x),
      delta_y = y - lag(y)
  ) |>
  ungroup() -> data

lm(delta_y ~ y_lag + x_lag, data = data) |> summary()
lm(y ~ y_lag + x_lag, data = data) |> summary()

```
They're again interchangeable by $\beta_{CLPM} = \beta_{LChange} + 1$. Let's simulate data from a latent change model, with no constant change. If we estimate a latent variable CLPM model, assuming the DGP is a latent change model with no constant change, the CLPM will accurately estimate the autoregressive parameters.


```{r}
lcsm_data <- simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.7,    # This should give CLPM beta ≈ 0.3
  beta_y = -0.7,    # This should give CLPM beta ≈ 0.3
  omega_x = 0.5,    # Cross-lagged coupling effects
  omega_y = 0.5,
  estimate_constant_change = FALSE,  # Important: no constant change
  sample.nobs = 10000
)
summary(lavaan(estimateCLPM(waves = 5), data = lcsm_data$data))
```

## Summary

With no "unit effects" the change score and level score models are equivalent, and the CLPM will correctly retrieve parameter estimates if the data are generated by a latent change model with no constant effects. Now, let's simulate data with constant change, and see what happens when we estimate CLPM, RICLPM, and Latent Change models.

## DGP: Latent Change with Constant Effects, Estimator: CLPM

```{r}
lcsm_data <- simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.7,    # This should give CLPM beta ≈ 0.3
  beta_y = -0.7,    # This should give CLPM beta ≈ 0.3
  omega_x = 0.5,    # Cross-lagged coupling effects
  omega_y = 0.5,
  estimate_constant_change = TRUE, 
  latent_variance_x = 0.5,
  latent_variance_y = 0.5,
  sample.nobs = 10000
)
summary(lavaan(estimateCLPM(waves = 5), data = lcsm_data$data))
```

The CLPM drastically over-estimates the autoregressive parameters, as expected. The value should 0.3, but is closer to 0.6. What about the RI-CLPM? Here, we estimate a "unit effect" though the parameterization is a bit different than the change score approach.


```{r}
lcsm_data <- simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.7,    # This should give CLPM beta ≈ 0.3
  beta_y = -0.7,    # This should give CLPM beta ≈ 0.3
  omega_x = 0.5,    # Cross-lagged coupling effects
  omega_y = 0.5,
  estimate_constant_change = TRUE, 
  latent_variance_x = 0.5,
  latent_variance_y = 0.5,
  sample.nobs = 10000
)
summary(lavaan(estimateRICLPM(waves = 5), data = lcsm_data$data))
```



```{r}
# Corrected version of your code
riclpm_data <- simRICLPM(
  waves = 10,
  beta_x = 0.3,     # Direct RICLPM parameter (not LCSM conversion)
  beta_y = 0.3,     # Direct RICLPM parameter
  omega_xy = 0.5,   # Y -> X cross-lagged effect
  omega_yx = 0.5,   # X -> Y cross-lagged effect
  var_p = 0.5,      # Within-person variance for X
  var_q = 0.5,      # Within-person variance for Y
  var_BX = 1.0,     # Random intercept variance for X  
  var_BY = 1.0,     # Random intercept variance for Y
  sample.nobs = 10000
)

summary(lavaan(estimateRICLPM(waves = 10), data = riclpm_data$data))
```

But, what if we simulate data under an RICLPM and fit a latent change model



```{r}
# Corrected version of your code
devtools::load_all()
library(lavaan)
riclpm_data <- simRICLPM(
  waves = 5,
  beta_x = 0.3,     # Direct RICLPM parameter (not LCSM conversion)
  beta_y = 0.3,     # Direct RICLPM parameter
  omega_xy = 0.3,   # Y -> X cross-lagged effect
  omega_yx = 0.3,   # X -> Y cross-lagged effect
  var_p = 0.5,      # Within-person variance for X
  var_q = 0.5,      # Within-person variance for Y
  var_BX = 1,     # Random intercept variance for X  
  var_BY = 1,     # Random intercept variance for Y
  sample.nobs = 10000
)

summary(lavaan(estimateLChange(waves = 5, "bivariate",
                               constrain_omega = TRUE,
                               constrain_beta  = TRUE,
                               estimate_constant_change = FALSE), 
               data = riclpm_data$data))
```




```{r, echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE }
library(lavaan)
devtools::load_all()
simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.3,
  beta_y = -0.3,
  omega_x = 0.5,
  omega_y = 0.5,
  estimate_constant_change = TRUE,
           # Covariance between change scores
  sample.nobs = 10000
)$data -> wide_data

data = wide_data |> 
  reshape_long_sim_cr() |> 
  group_by(id) |>
  mutate(
    y_lag = lag(y),
    x_lag = lag(x),
    delta_y = y - lag(y)
  ) |>
  ungroup() -> data

lm(delta_y ~ y_lag + x_lag, data = data) |> summary()
lm(y ~ y_lag + x_lag, data = data) |> summary()
```

The Latent Change Model (unsurprisingly) almost perfectly retrieves the parameter estimates.

```{r}
model = lavaan::lavaan(
  model = estimateLChange(waves = 5,
                variable_type = "bivariate",
                constrain_omega = TRUE,
                constrain_beta =  TRUE,
                estimate_constant_change = TRUE),
  data = wide_data) 
summary(model)
```


```{r}
model = lavaan::lavaan(
  model = estimateRICLPM(waves = 5,
                constrain_omega = TRUE,
                constrain_beta =  TRUE),
  data = wide_data) 
summary(model)
```


Each estimation function comes with a simulate data function, allowing users to generate data under the assumptions of each model. These functions are

* `simCLPM()` simulates data from a standard cross-lagged panel model.
* `simRICLPM()` simulates data from a random-intercept cross-lagged panel model.
* `simLChange()` simulates data from a latent change score model.
* `simLGM()` simulates data from a latent growth model.

Documentation is included for each of the functions and can be accessed with the `help()` function. For example, let's simulated data using a bivariate latent change score model, and then estimate CLPM, RICLPM, Latent Change, and Latent Growth models, on this data set.

### What Happens with Constant Change

Constant change is a "unit effect" so let's examine how this affects the CLPM, RICLPM and LCHANGE model.

* $\beta = -0.3$ (autoregressive/proportional change)
* $\omega=  0.3$ (cross lag/cross proportinal change)
* waves = 5
* n = 5000

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
library(lavaan)
devtools::load_all()
simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.3,
  beta_y = -0.3,
  omega_x = 0.5,
  omega_y = 0.5,
  estimate_constant_change = TRUE,
           # Covariance between change scores
  sample.nobs = 10000
)$data |> 
  reshape_long_sim_cr() |> 
  group_by(id) |>
  mutate(
    y_lag = lag(y),
    x_lag = lag(x),
    delta_y = y - lag(y)
  ) |>
  ungroup() -> data

lm(delta_y ~ y_lag + x_lag, data = data) |> summary()
lm(y ~ y_lag + x_lag, data = data) |> summary()
```
```

```{r}
# Simulate a five wave panel, with two variables, x y:
single_change_data <- simLChange(
  waves = 3,
  variable_type = "bivariate",
  beta_x = -0.3,
  beta_y = -0.3,
  omega_x = 0.5,
  omega_y = 0.5,
  estimate_constant_change = FALSE,
           # Covariance between change scores
  sample.nobs = 10000
)$data 
```

First examining the results of the latent change score model, it is clear that the model retrieves the correct parameter estimates.

```{r, echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE }
model = lavaan::lavaan(
  model = estimateLChange(waves = 3,
                variable_type = "bivariate",
                constrain_omega = TRUE,
                constrain_beta =  TRUE,
                estimate_constant_change = FALSE),
  data = single_change_data) 
summary(model)
```
The estimate of $beta = -0.3$ and $\omega = 0.3$ are correct.

We can similarly estimate a five wave CLPM. Here, we would expect roughly the same $\omega$ estimates, but the $\beta$ parameters are $\omega_{Latent change} + 1 = \omega_{CLPM}$
This also appears to be the case, though the CLPM is still off by a bit.


```{r}
library(lavaan)
library(tidyverse)
fit = lavaan(
  model = estimateCLPM(waves = 3, 
                       estimate_means = TRUE,
                       constrain_beta = TRUE, 
                       constrain_omega = TRUE,
                       constrain_residual_variances = TRUE, 
                       constrain_residual_covariances = TRUE),
  data = single_change_data) 
summary(fit)
```
But, according to the data generating process, the auto-regressive parameter should be approximately 0.7. The RICLPM gets this correct.

```{r}

single_change_data <- simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.3,
  beta_y = -0.3,
  omega_x = 0.3,
  omega_y = 0.3,
  sample.nobs = 1000
)$data -> dat

model = lavaan::lavaan(
  model = estimateRICLPM(waves = 5,
                         time_varying_x = paste0("x", 1:5),
                         time_varying_y = paste0("y", 1:5)),
  data = dat)
summary(model)
```
```

* `simCLPM` generates data from a standard cross-lagged panel model.
* `simRICLPM` generates data from a random-intercept cross-lagged panel model.


The $\texttt{crossLagR}$ package includes several functions to simulate data.

$\texttt{simRICLPM()}$ simulates data from a random intercept cross-lagged panel model.

$\texttt{simCLPM()}$ simulates data from a cross-lagged panel model.

$\texttt{reshape\_long\_sim\_cr()}$ Takes a wide data frame, pivots to wide format, includes lags.


```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
# devtools::load_all()
library(dplyr)

df = simCLPM(waves = 5,
             variance_p = 0.5,      # underscore
             variance_q = 0.5,      # underscore
             stability_p = 0.9,      # underscore
             stability_q = 0.9,      # underscore
             cross_q = 0,
             cross_p = 0,
             cov_pq = 0.00,
             means_p = c(1,1.1,1.2,1.3,1.4),
             sample.nobs = 1000)$data
  df |>
  mutate(id = seq(1:nrow(df)))  |>
  reshape_long_sim_cr() -> dat_long
head(dat_long)
lm(y ~  ylag + xlag, data = dat_long)
```
### Trajectories

```{r}
library(dplyr)
library(ggplot2)
dat_long |> 
  ggplot(aes(x = wave, y = y, group = id)) +
  geom_line(alpha = 0.1, color = "black", position = position_jitter(width = 0.1, height = 0.2)) +
  # geom_point(alpha = 0.3, size = 0.5, position = position_jitter(width = 0.1, height = 0.2)) +
  stat_summary(aes(group = 1), fun = mean, geom = "line", 
               color = "lightblue", size = 1, alpha = 0.8) +
  stat_summary(aes(group = 1), fun = mean, geom = "point", 
               color = "lightblue", size = 1) +
  labs(
    title = "Individual Trajectories: Simulated Data",
    subtitle = "Linear Trend",
    x = "Survey Wave",
    y = "Response"
  ) +
  theme_minimal() +
  scale_y_continuous(limits = c(-5, 6) ) +
  theme(strip.text = element_text(color = "black")) -> plot
print(plot)
```

```{r}
dat_long <- dat_long |>
  mutate(
    # xlag = if_else(is.na(xlag), mean(x, na.rm = TRUE), xlag),
    # ylag = if_else(is.na(ylag), mean(y, na.rm = TRUE), ylag),
    predicted = predict(lm(y ~ ylag + xlag, data = dat_long), newdata = dat_long)
  )
dat_long |> 
  ggplot(aes(x = wave, y = y, group = id)) +
  geom_line(alpha = 0.1, color = "black", position = position_jitter(width = 0.1, height = 0.2)) +
  # Observed mean trend
  stat_summary(aes(group = 1), fun = mean, geom = "line", 
               color = "lightblue", size = 1, alpha = 0.8) +
  stat_summary(aes(group = 1), fun = mean, geom = "point", 
               color = "lightblue", size = 1) +
  # Model predictions mean trend
  stat_summary(aes(y = predicted, group = 1), fun = mean, geom = "line", 
               color = "red", size = 1, alpha = 0.8, na.rm = TRUE) +
  stat_summary(aes(y = predicted, group = 1), fun = mean, geom = "point", 
               color = "red", size = 1, na.rm = TRUE) +
  labs(
    title = "Individual Trajectories: Simulated Data",
    subtitle = "Observed (blue) vs CLPM Predicted (red) trends",
    x = "Survey Wave",
    y = "Response"
  ) +
  theme_minimal() +
  scale_y_continuous(limits = c(-5, 6)) +
  theme(strip.text = element_text(color = "black"))


```
### Cross-Lagged Panel Model

Let's fit several models under a random intercept cross lagged panel data generating process.

```{r}
data = simCLPM(waves = 5,
             variance_p = 0.5,      # underscore
             variance_q = 0.5,      # underscore
             stability_p = 0.9,      # underscore
             stability_q = 0.9,      # underscore
             cross_q = 0,
             cross_p = 0,
             cov_pq = 0.00,
             # means_p = c(1,1.1,1.2,1.3,1.4),
             sample.nobs = 1000)$data

lavaan::lavaan(estimateLChange(waves = 3,
                               constrain_omega = TRUE,
                               constrain_beta =  TRUE),
              data = data,
              int.ov.free = TRUE, # Fix intercepts to zero
              estimator="ml") |>
  lavaan::summary()

```

```{r}
library(crossLagR)
library(lavaan)
# Simulate Data Under RI CLPM
df = simRICLPM(waves = 5,
                variance.p = 0.5,
                variance.q = 0.5,
                stability.p = 0.20,
                stability.q = 0.20,
                cross.q = 0.30,
                cross.p = 0.30,
                cov.pq = 0.00,
                variance.between.x = 0.5,
                variance.between.y = 0.5,
                cov.between = 0,
                sample.nobs = 10e2)
df[[2]] %>%
  mutate(id = seq(1:nrow(df[[2]])))  -> dat
dat %>%
  reshape_long_sim_cr() -> dat_long

fit1 <- lavaan(estimateCLPM(waves = 5),
              data = dat,
              int.ov.free = TRUE, # Fix intercepts to zero
              estimator="ml")

summary(fit1)
```

### Random Intercept Cross-Lagged Panel Model

```{r}
devtools::load_all()
library(lavaan)
WAVES = 5

fit2 <- lavaan(estimateRICLPM(data= dat,
                              waves = WAVES, 
                              time_varying_x = paste0("x", 1:WAVES), 
                              time_varying_y = paste0("y", 1:WAVES)),
              data = dat,
              int.ov.free = TRUE, # Fix intercepts to zero
              estimator="ml")

summary(fit2)
```

The CLPM clearly does not fit the data well, and provides rather inaccurate estimates.

### Hiearchical Linear Model, Random Intercepts and Slopes

```{r, echo = FALSE, message = FALSE, warning = FALSE}
model = estimateHLM(data = dat_long, residual_correlation = FALSE)
summary(model)
```

### Continuous Time Model

```{r, echo = FALSE, message = FALSE, warning = FALSE}
dat_long %>%
  select(id, wave, x, y) -> ct_sem_data
# ctsem package Follows this convention:
names(ct_sem_data) = c("id", "time", "x", "y")
model = estimateCTSEM(data = ct_sem_data)
# [1] Returns a list; Extract cstem model
# [2] Return a discrete time CL and AR model
summary(model[[1]])$parmatrices
print(model[[2]] %>% t())
```

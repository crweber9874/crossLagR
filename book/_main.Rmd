--- 
title: "Cross Lagged Regression"
author: "Christopher Weber"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]  # ← First one
description: |
  Cross Lagged Regression
link-citations: yes
github-repo: crweber9874/advancedRegression
---
--- 
title: "Cross Lagged Regression"
author: "Christopher Weber"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]  # ← First one
description: |
  Cross Lagged Regression
link-citations: yes
github-repo: crweber9874/advancedRegression
---


# Preface {-}

The Cross-Lagged Panel Model (CLPM) is widely accepted as a standard method for longitudinal causal analysis in political science. Its application, however, is often susceptible to unaccounted time-invariant confounders and measurement error, leading to spurious estimates of autoregressive and cross-lagged relationships, as well as bias in statistical inferences and substantive conclusions. In these documentation files, I demonstrate the similarities and differences between different panel analysis models, showing in particular, that the standard CLPM is strongly related to a more flexible and robust alternatives, the change score regression model and the random-intercept cross-lagged regression model. Both the Latent Change Model (LCM) and the Random Intercept Cross-Lagged Panel Model (RI-CLPM) extend the standard CLPM by explicitly modeling "unit level" effects. In simulations and empirical examples, we show the myriad paths by which the CLPM produces biased parameter estimates due to unmodeled, stable-unit effects. Both approaches allow for "constant" differences between units over time: In the RI-CLPM, this is represented by a factor corresponding to unit-mean variation in the observed variables, a "random-intercept" while in the LCM, this is captured through a factor corresponding to unit-level change over time, a "random slope."

This documentation elaborates upon:

* The theoretical background for the CLPM, RI-CLPM, and LCM, highlighting their similarities and differences.
* An introduction to the `crossLagR` package, which includes various utilities to estimate and simulate effects from these models.
* A Monte Carlo simulation procedure that examines the degree of bias in parameter estimates from the CLPM, RI-CLPM, and LCM under different data-generating processes.



<!--chapter:end:index.Rmd-->


# Panel Data Models

Placeholder


## The Cross-Lagged Panel Model 
## The Change Score Regression
## Example: CLPM and Change Score Regression
## Types of Change
## Unit Effects
## The Random Intercept Cross Lagged Regression 
## The Latent Growth Model
## Measurement Error

<!--chapter:end:01_Panel_Models.Rmd-->

# Panel Data Analysis

The package that accompanies this summary, `crossLagR`, includes functions to estimate several panel data models.

**Install and Load**

```{r}
# devtools::install_github("https://github.com/crweber9874/crossLagR/crossLagR")
library(crossLagR)
```

* `estimateCLPM()` generates the syntax for cross-lagged panel models. Use `help(estimateRICLPM)` to modify constraints and number of waves.
* `estimateRICLPM()` generates the syntax for random-intercept cross-lagged panel models. Use `help(estimateRICLPM)` to modify constraints and number of waves.
* `estimateLChange()` generates the syntax for latent change score model. Use `help(estimateLChange)` to modify constraints and number of waves.

Nearly all the functions in the package start with a core lavaan model -- such as the RICLPM [@hamaker2015]. From there, build in rules to implement constraints, extend the number of waves, and modify parameters. You could just print the model code and modify manually. For instance, the `lavaan` code to estimate the CLPM is,

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
estimateCLPM(waves = 2,
                         constrain_beta = TRUE,
                         constrain_omega = TRUE,
                         constrain_residual_variances = TRUE,
                         constrain_residual_covariances = TRUE,
                         estimate_means = FALSE) |>
cat()
```  

The `lavaan` code to estimate the Bivariate Latent Change Model is,

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
rm(list = ls())
devtools::load_all()
estimateLChange(waves = 3,
                variable_type = "bivariate",
                constrain_omega = TRUE,
                constrain_beta =  TRUE) |>
  cat()
```

And the RICLPM model is,

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
rm(list = ls())
devtools::load_all()
estimateRICLPM(waves = 3,
                constrain_omega = TRUE,
                constrain_beta =  TRUE) |>
  cat()
```
                       
And finally, the Bivariate Latent (Linear) Growth Model,

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
estimateLGM(waves = 3,
            variable_type = "bivariate"
) |>
cat()
```  

## Simulation

Each estimation function comes with a simulate data function, allowing users to generate data under the assumptions of each model. These functions are

* `simCLPM()` simulates data from a standard cross-lagged panel model.
* `simRICLPM()` simulates data from a random-intercept cross-lagged panel model.
* `simLChange()` simulates data from a latent change score model.
* `simLGM()` simulates data from a latent growth model.

Documentation is included for each of the functions and can be accessed with the `help()` function. For example, let's simulated data using a bivariate latent change score model, and then estimate CLPM, RICLPM, Latent Change, and Latent Growth models, on this data set.

### Specifications

* $\beta = -0.3$ (autoregressive/proportional change)
* $\omega=  0.3$ (cross lag/cross proportinal change)
* waves = 5
* n = 5000
* No Constant Change

```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
library(lavaan)
single_change_data <- simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.3,
  beta_y = -0.3,
  omega_x = 0.3,
  omega_y = 0.3,
  latent_variance_x = 0.1,
  latent_variance_y = 0.1,
  sample.nobs = 5000,
  estimate_constant_change = FALSE
)$data -> dat
```


First examining the results of the latent change score model, it is clear that the model retrieves the correct parameter estimates.

```{r, echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE }
model = lavaan::lavaan(
  model = estimateLChange(waves = 5,
                variable_type = "bivariate",
                constrain_omega = TRUE,
                constrain_beta =  TRUE,
                estimate_constant_change = FALSE),
  data = dat) 
summary(model)
```
The estimate of $beta = -0.3$ and $\omega = 0.3$ are correct.

We can similarly estimate a five wave CLPM. Here, we would expect roughly the same $\omega$ estimates, but the $\beta$ parameters are $\omega_{Latent change} + 1 = \omega_{CLPM}$
This also appears to be the case.


```{r}
library(lavaan)
library(tidyverse)
fit = lavaan(
  model = estimateCLPM(waves = 5, estimate_means = FALSE),
  data = dat) 
summary(fit)
```
But, according to the data generating process, the auto-regressive parameter should be approximately 0.7. The RICLPM gets this correct.

```{r}

single_change_data <- simLChange(
  waves = 5,
  variable_type = "bivariate",
  beta_x = -0.3,
  beta_y = -0.3,
  omega_x = 0.3,
  omega_y = 0.3,
  sample.nobs = 1000
)$data -> dat

model = lavaan::lavaan(
  model = estimateRICLPM(waves = 5,
                         time_varying_x = paste0("x", 1:5),
                         time_varying_y = paste0("y", 1:5)),
  data = dat)
summary(model)
```
```

* `simCLPM` generates data from a standard cross-lagged panel model.
* `simRICLPM` generates data from a random-intercept cross-lagged panel model.


The $\texttt{crossLagR}$ package includes several functions to simulate data.

$\texttt{simRICLPM()}$ simulates data from a random intercept cross-lagged panel model.

$\texttt{simCLPM()}$ simulates data from a cross-lagged panel model.

$\texttt{reshape\_long\_sim\_cr()}$ Takes a wide data frame, pivots to wide format, includes lags.


```{r, echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE }
# devtools::load_all()
library(dplyr)

df = simCLPM(waves = 5,
             variance_p = 0.5,      # underscore
             variance_q = 0.5,      # underscore
             stability_p = 0.9,      # underscore
             stability_q = 0.9,      # underscore
             cross_q = 0,
             cross_p = 0,
             cov_pq = 0.00,
             means_p = c(1,1.1,1.2,1.3,1.4),
             sample.nobs = 1000)$data
  df |>
  mutate(id = seq(1:nrow(df)))  |>
  reshape_long_sim_cr() -> dat_long
head(dat_long)
lm(y ~  ylag + xlag, data = dat_long)
```
### Trajectories

```{r}
library(dplyr)
library(ggplot2)
dat_long |> 
  ggplot(aes(x = wave, y = y, group = id)) +
  geom_line(alpha = 0.1, color = "black", position = position_jitter(width = 0.1, height = 0.2)) +
  # geom_point(alpha = 0.3, size = 0.5, position = position_jitter(width = 0.1, height = 0.2)) +
  stat_summary(aes(group = 1), fun = mean, geom = "line", 
               color = "lightblue", size = 1, alpha = 0.8) +
  stat_summary(aes(group = 1), fun = mean, geom = "point", 
               color = "lightblue", size = 1) +
  labs(
    title = "Individual Trajectories: Simulated Data",
    subtitle = "Linear Trend",
    x = "Survey Wave",
    y = "Response"
  ) +
  theme_minimal() +
  scale_y_continuous(limits = c(-5, 6) ) +
  theme(strip.text = element_text(color = "black")) -> plot
print(plot)
```

```{r}
dat_long <- dat_long |>
  mutate(
    # xlag = if_else(is.na(xlag), mean(x, na.rm = TRUE), xlag),
    # ylag = if_else(is.na(ylag), mean(y, na.rm = TRUE), ylag),
    predicted = predict(lm(y ~ ylag + xlag, data = dat_long), newdata = dat_long)
  )
dat_long |> 
  ggplot(aes(x = wave, y = y, group = id)) +
  geom_line(alpha = 0.1, color = "black", position = position_jitter(width = 0.1, height = 0.2)) +
  # Observed mean trend
  stat_summary(aes(group = 1), fun = mean, geom = "line", 
               color = "lightblue", size = 1, alpha = 0.8) +
  stat_summary(aes(group = 1), fun = mean, geom = "point", 
               color = "lightblue", size = 1) +
  # Model predictions mean trend
  stat_summary(aes(y = predicted, group = 1), fun = mean, geom = "line", 
               color = "red", size = 1, alpha = 0.8, na.rm = TRUE) +
  stat_summary(aes(y = predicted, group = 1), fun = mean, geom = "point", 
               color = "red", size = 1, na.rm = TRUE) +
  labs(
    title = "Individual Trajectories: Simulated Data",
    subtitle = "Observed (blue) vs CLPM Predicted (red) trends",
    x = "Survey Wave",
    y = "Response"
  ) +
  theme_minimal() +
  scale_y_continuous(limits = c(-5, 6)) +
  theme(strip.text = element_text(color = "black"))


```
### Cross-Lagged Panel Model

Let's fit several models under a random intercept cross lagged panel data generating process.

```{r}
data = simCLPM(waves = 5,
             variance_p = 0.5,      # underscore
             variance_q = 0.5,      # underscore
             stability_p = 0.9,      # underscore
             stability_q = 0.9,      # underscore
             cross_q = 0,
             cross_p = 0,
             cov_pq = 0.00,
             # means_p = c(1,1.1,1.2,1.3,1.4),
             sample.nobs = 1000)$data

lavaan::lavaan(estimateLChange(waves = 3,
                               constrain_omega = TRUE,
                               constrain_beta =  TRUE),
              data = data,
              int.ov.free = TRUE, # Fix intercepts to zero
              estimator="ml") |>
  lavaan::summary()

```

```{r}
library(crossLagR)
library(lavaan)
# Simulate Data Under RI CLPM
df = simRICLPM(waves = 5,
                variance.p = 0.5,
                variance.q = 0.5,
                stability.p = 0.20,
                stability.q = 0.20,
                cross.q = 0.30,
                cross.p = 0.30,
                cov.pq = 0.00,
                variance.between.x = 0.5,
                variance.between.y = 0.5,
                cov.between = 0,
                sample.nobs = 10e2)
df[[2]] %>%
  mutate(id = seq(1:nrow(df[[2]])))  -> dat
dat %>%
  reshape_long_sim_cr() -> dat_long

fit1 <- lavaan(estimateCLPM(waves = 5),
              data = dat,
              int.ov.free = TRUE, # Fix intercepts to zero
              estimator="ml")

summary(fit1)
```

### Random Intercept Cross-Lagged Panel Model

```{r}
devtools::load_all()
library(lavaan)
WAVES = 5

fit2 <- lavaan(estimateRICLPM(data= dat,
                              waves = WAVES, 
                              time_varying_x = paste0("x", 1:WAVES), 
                              time_varying_y = paste0("y", 1:WAVES)),
              data = dat,
              int.ov.free = TRUE, # Fix intercepts to zero
              estimator="ml")

summary(fit2)
```

The CLPM clearly does not fit the data well, and provides rather inaccurate estimates.

### Hiearchical Linear Model, Random Intercepts and Slopes

```{r, echo = FALSE, message = FALSE, warning = FALSE}
model = estimateHLM(data = dat_long, residual_correlation = FALSE)
summary(model)
```

### Continuous Time Model

```{r, echo = FALSE, message = FALSE, warning = FALSE}
dat_long %>%
  select(id, wave, x, y) -> ct_sem_data
# ctsem package Follows this convention:
names(ct_sem_data) = c("id", "time", "x", "y")
model = estimateCTSEM(data = ct_sem_data)
# [1] Returns a list; Extract cstem model
# [2] Return a discrete time CL and AR model
summary(model[[1]])$parmatrices
print(model[[2]] %>% t())
```

<!--chapter:end:02_CLPM_Estimation.Rmd-->

